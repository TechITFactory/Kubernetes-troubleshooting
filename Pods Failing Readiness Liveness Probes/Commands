package.json
{
  "name": "failing-health-app",
  "version": "1.0.0",
  "description": "Demo app for Kubernetes health check troubleshooting",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "author": "Kubernetes Training",
  "license": "MIT"
}


 server.js (Failing Version)
const express = require('express');
const app = express();

let healthy = false;
let startupTime = Date.now();

// Simulate slow startup - takes 60 seconds to become healthy
setTimeout(() => {
  healthy = true;
  console.log('Application is now healthy');
}, 60000);

app.get('/', (req, res) => {
  res.send(`Hello World! App running for ${Math.floor((Date.now() - startupTime) / 1000)} seconds`);
});

app.get('/health', (req, res) => {
  console.log(`Health check called. Healthy: ${healthy}`);
  if (healthy) {
    res.status(200).json({
      status: 'healthy',
      uptime: Math.floor((Date.now() - startupTime) / 1000),
      timestamp: new Date().toISOString()
    });
  } else {
    res.status(503).json({
      status: 'not ready',
      uptime: Math.floor((Date.now() - startupTime) / 1000),
      timestamp: new Date().toISOString(),
      message: 'Still initializing...'
    });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server starting on port ${PORT}. Will be healthy in 60 seconds...`);
});


Complete Docker Build Commands
mkdir k8s-health-demo
cd k8s-health-demo

# Create the files (package.json, server.js from above)
# docker build -t failing-health-app:v1 .
minikube image load failing-health-app:v1

apiVersion: apps/v1
kind: Deployment
metadata:
  name: failing-health-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: failing-health-demo
  template:
    metadata:
      labels:
        app: failing-health-demo
    spec:
      containers:
      - name: app
        image: failing-health-app:v1
        imagePullPolicy: Never  # For local images
        ports:
        - containerPort: 3000
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5   # TOO AGGRESSIVE - app needs 60s to be healthy
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 2      # TOO STRICT - fails after only 2 attempts
          successThreshold: 1
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10  # TOO AGGRESSIVE - will start failing immediately
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3      # Will cause container restarts
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: failing-health-service
spec:
  selector:
    app: failing-health-demo
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP

---
Observe the Problem:
# See the unhealthy pods
kubectl get pods -l app=failing-health-demo
# READY column shows 0/1 for all pods

# Check service endpoints (should be empty)
kubectl get endpoints failing-health-service
# No endpoints because no pods are ready

# Watch logs to see health check failures
kubectl logs -l app=failing-health-demo -f

--------------------------------
server-fixed.js (Working Version)
const express = require('express');
const app = express();

let healthy = true; // Start healthy immediately
let ready = false;
let startupTime = Date.now();

// Simulate faster startup - ready in 10 seconds
setTimeout(() => {
  ready = true;
  console.log('Application is now ready to serve traffic');
}, 10000);

app.get('/', (req, res) => {
  res.send(`Hello World! App running for ${Math.floor((Date.now() - startupTime) / 1000)} seconds`);
});

// Liveness probe - basic health check
app.get('/alive', (req, res) => {
  console.log('Liveness check called');
  if (healthy) {
    res.status(200).json({
      status: 'alive',
      uptime: Math.floor((Date.now() - startupTime) / 1000),
      timestamp: new Date().toISOString()
    });
  } else {
    res.status(503).json({
      status: 'dead',
      timestamp: new Date().toISOString()
    });
  }
});

// Readiness probe - comprehensive readiness check
app.get('/ready', (req, res) => {
  console.log(`Readiness check called. Ready: ${ready}`);
  if (ready && healthy) {
    res.status(200).json({
      status: 'ready',
      uptime: Math.floor((Date.now() - startupTime) / 1000),
      timestamp: new Date().toISOString()
    });
  } else {
    res.status(503).json({
      status: 'not ready',
      uptime: Math.floor((Date.now() - startupTime) / 1000),
      timestamp: new Date().toISOString(),
      message: ready ? 'Healthy but not ready' : 'Still initializing...'
    });
  }
});

// Legacy health endpoint for backward compatibility
app.get('/health', (req, res) => {
  res.redirect('/ready');
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server starting on port ${PORT}. Will be ready in 10 seconds...`);
});

------------------------------------------------------
# fixed-probe-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: health-demo-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: health-demo
  template:
    metadata:
      labels:
        app: health-demo
    spec:
      containers:
      - name: app
        image: failing-health-app:v2
        imagePullPolicy: Never  # For local images
        ports:
        - containerPort: 3000
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 15  # Wait for app initialization
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
          successThreshold: 1
        livenessProbe:
          httpGet:
            path: /alive
            port: 3000
          initialDelaySeconds: 20   # Start after readiness probe
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 5       # More lenient for liveness
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: health-demo-service
spec:
  selector:
    app: health-demo
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP
